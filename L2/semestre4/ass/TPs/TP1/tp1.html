<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>CIRC2 &#x2013; Assembleur et Circuits 2 &#x2013; Fiche de TP numéro 1</title>
<!-- 2018-01-22 lun. 15:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Said Jabbour" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CIRC2 &#x2013; Assembleur et Circuits 2 &#x2013; Fiche de TP numéro 1</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Obtenir un exécutable</a>
<ul>
<li><a href="#sec-1-1">1.1. Assembleur et édition de liens</a></li>
<li><a href="#sec-1-2">1.2. Avec gcc</a></li>
<li><a href="#sec-1-3">1.3. Dans la suite</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Travailler avec le débogueur gdb</a>
<ul>
<li><a href="#sec-2-1">2.1. Lancer le débogueur</a></li>
<li><a href="#sec-2-2">2.2. Exécuter pas à pas</a></li>
<li><a href="#sec-2-3">2.3. Ausculter le contenu de la mémoire, des registres</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Exercices</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Obtenir un exécutable</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Assembleur et édition de liens</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Nous allons regarder ici la décomposition en deux étapes du passage d'un programme en langage assembleur à un exécutable (en langage machine).
</p>

<ul class="org-ul">
<li>Copiez le code ci-dessous dans un fichier <code>premier_start.s</code>. 
</li>
</ul>
<pre class="example">
        .data			# zone de données
nb1: 	.byte 	1		# valeur 1 en décimal nommée nb1 
res:	.byte 	0		# valeur 0 en décimal nommée res
	
    	.text 			# zone d'instructions
	.global	_start	
_start: movb 	nb1, %al	# déplacer la valeur dans l'octet 
    				# à l'adresse nb1 vers le registre al
    	addb 	$5, %al		# ajouter la valeur 5 (en décimal) 
    				# à la valeur dans le registre al
    	movb 	%al, res	# poser la valeur dans le registre al 
    				# dans l'octet à l'adresse res
	mov	$1, %eax	# fonction 1: quitter le programme
	mov	$0, %ebx	# code de retour du programme
	int 	$0x80		# appel de la fonction
</pre>
<ul class="org-ul">
<li>La première étape est de construire le programme en langage machine en appelant l'assembleur : 
</li>
</ul>
<pre class="example">
$moi@mamachine:~/circ2/tps$ as premier_start.s -o premier_start.o
</pre>
<ul class="org-ul">
<li><code>premier\_start.o</code> n'est pas encore un exécutable : il faut encore passer par l'édition de liens qui ajoutera les informations nécessaires (liens vers des librairies externes par exemple) 
</li>
</ul>
<pre class="example">
$moi@mamachine:~/circ2/tps$ ld premier_start.o -o premier_start
</pre>
<ul class="org-ul">
<li>Vous pouvez maintenant exécuter votre programme :
</li>
</ul>
<pre class="example">
$moi@mamachine:~/circ2/tps$ ./premier_start
</pre>
<ul class="org-ul">
<li>Vous pouvez regarder le code résultat retourné par votre programme (0 indique que tout s'est bien passé) : 
</li>
</ul>
<pre class="example">
$moi@mamachine:~/circ2/tps$ echo $?
0
</pre>
</div>
</div>


<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Avec gcc</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Une autre possibilité est de laisser faire les deux étapes (assembleur et édition de liens) par le compilateur <code>gcc</code> qui lancera les deux appels. Dans ce cas-là, la séquence d'introduction du programme est légèrement différente. Modifiez votre programme initial en suivant les instructions suivantes et enregistrez-le sous <code>premier.s</code> : 
</p>
<pre class="example">
	/* Premier programme en assembleur !
	*/
	.data			# zone de données
nb1: 	.byte 	1		# valeur 1 en décimal nommée nb1 
res:	.byte 	0		# valeur 0 en décimal nommée res
	
    	.text 			# zone d'instructions
	.globl	main
main:   movb 	nb1, %al	# déplacer la valeur dans l'octet 
    				# à l'adresse nb1 vers le registre al
    	addb 	$5, %al		# ajouter la valeur 5 (en décimal) 
    				# à la valeur dans le registre al
    	movb	%al, res	# poser la valeur dans le registre al 
    				# dans l'octet à l'adresse res
	mov	$1, %eax	# fonction 1: quitter le programme
	mov	$0, %ebx	# code de retour du programme
	int 	$0x80		# appel de la fonction
</pre>



<p>
La différence se situe sur l'étiquette attendue pour le début de programme (<code>main</code> eu lieu de <code>_start</code>). On peut maintenant appeler <code>gcc</code> qui s'occupera d'appeler l'assembleur et l'édition de liens : 
</p>
<pre class="example">
$moi@mamachine:~/circ2/tps$ gcc premier.s -o premier
</pre>

<p>
Vous pouvez maintenant exécuter votre programme : 
</p>
<pre class="example">
$moi@mamachine:~/circ2/tps$ ./premier
</pre>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Dans la suite</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Nous utiliserons toujours le compilateur <code>gcc</code>, avec l'option <code>-g</code> pour pouvoir utiliser pleinement le débogueur ensuite :
</p>
<pre class="example">
$moi@mamachine:~/circ2/tps$ gcc -g premier.s -o premier
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Travailler avec le débogueur gdb</h2>
<div class="outline-text-2" id="text-2">
<p>
L'objectif est de tracer le déroulement d'un programme en assembleur : connaître l'état des registres, les valeurs contenues dans la mémoire, &hellip; Cette trace permet de vérifier finement et de corriger, le cas échéant, votre programme. Vous devez suivre les instructions (et faire vos essais) sur votre programme.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Lancer le débogueur</h3>
<div class="outline-text-3" id="text-2-1">
<p>
On appelle le débogueur sur l'exécutable.
</p>

<pre class="example">
$moi@mamachine:~/circ2/tps$ gdb premier
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from premier...done.
(gdb)
</pre>

<p>
La commande <code>help</code> vous apporte toutes les informations nécessaires, essayez avec <code>help run</code> et <code>help quit</code>. Les raccourcis pour ces deux commandes sont <code>r</code> et <code>q</code>.
</p>

<p>
Si on lance l'exécution du programme, et qu'ensuite on quitte le débogueur :
</p>
<pre class="example">
(gdb) run
Starting program: /home/anne/enseign/numcirc2/15-16/src/premier 
[Inferior 1 (process 27501) exited normally]
(gdb) q
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Exécuter pas à pas</h3>
<div class="outline-text-3" id="text-2-2">
<p>
On peut arrêter le programme à des endroits spécifiques, en utilisant les étiquettes d'instructions, ou les numéros de ligne.
</p>
<pre class="example">
$moi@mamachine:~/circ2/tps$ gdb -q premier
Reading symbols from premier...done.
(gdb) break main
Note : point d'arrêt 1 also set at pc 0x4004f6.
Breakpoint 3 at 0x4004f6: file premier.s, line 9.
(gdb) r
Starting program: /home/anne/enseign/numcirc2/15-16/src/premier 

Breakpoint 1, main () at premier.s:9
9	main:   movb 	nb1, %al	# déplacer la valeur dans l'octet
</pre>


<p>
On peut regarder le code source (regardez <code>help list</code> pour comprendre les options possibles) :
</p>
<pre class="example">
(gdb) list
4	nb1: 	.byte 	1		# valeur 1 en décimal nommée nb1 
5	res:	.byte 	0		# valeur 0 en décimal nommée res
6		
7	    	.text 			# zone d'instructions
8		.globl	main
9	main:   movb 	nb1, %al	# déplacer la valeur dans l'octet 
10	    				# à l'adresse nb1 vers le registre al
11	    	addb 	$5, %al		# ajouter la valeur 5 (en décimal) 
12	    				# à la valeur dans le registre al
13	    	movb	%al, res	# poser la valeur dans le registre al
</pre>




<div class="inlinetask">
<b>Questions</b><br  />
<ol class="org-ol">
<li>Comment afficher le code autour de la ligne 5 ?
</li>
<li>Comment afficher le code de la ligne 8 à 11 ?
</li>
</ol>
</div>

<p>
On peut maintenant avancer pas à pas dans l'exécution du programme.
</p>
<pre class="example">
(gdb) nexti
11	    	addb 	$5, %al		# ajouter la valeur 5 (en décimal) 
(gdb) stepi
13	    	movb	%al, res	# poser la valeur dans le registre al 
(gdb) stepi
15		mov	$1, %eax	# fonction 1: quitter le programme
</pre>

<p>
L'instruction <code>nexti</code> (raccourci <code>ni</code>) exécute la prochaine instruction. Dans le cas d'un appel à une fonction, elle ne rentre pas dans la fonction. L'instruction <code>stepi</code> (raccourci <code>si</code>) exécute la prochaine instruction et, le cas échéant, rentre à l'intérieur des sous-programmes. Pour ces deux instructions, on peut préciser le nombre de pas à faire.
</p>

<p>
L'instruction <code>continue</code> permet d'avancer entre deux points d'arrêt. On reprend au début de l'exécution de notre programme
</p>
<pre class="example">
(gdb) break main
Breakpoint 1 at 0x4004f6: file premier.s, line 9.
(gdb) break 13
Breakpoint 2 at 0x4004ff: file premier.s, line 13.
(gdb) run
Starting program: /home/anne/enseign/numcirc2/15-16/src/premier 

Breakpoint 1, main () at premier.s:9
9	main:   movb 	nb1, %al	# déplacer la valeur dans l'octet 
(gdb) continue
Continuing.

Breakpoint 2, main () at premier.s:13
13	    	movb	%al, res	# poser la valeur dans le registre al
</pre>

<p>
L'instruction <code>backtrace</code> (raccourci <code>bt</code>) retourne la pile d'appels. L'adresse au sommet est la prochaine instruction à exécuter.
</p>

<p>
L'instruction <code>clear</code> permet de supprimer un point d'arrêt par son étiquette ou son numéro de ligne associé, l'instruction <code>delete</code> fait la même chose mais on indique le numéro du point d'arrêt.
</p>

<pre class="example">
(gdb) clear main
Point d'arrêt supprimé 1 
(gdb) info break
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000004004ff premier.s:13
	breakpoint already hit 1 time
(gdb) delete 2
(gdb) info break
No breakpoints or watchpoints.
</pre>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Ausculter le contenu de la mémoire, des registres</h3>
<div class="outline-text-3" id="text-2-3">
<p>
L'information complète est donnée par la commande <code>info</code>. Utilisez <code>help info</code> pour connaître toutes les possibilités (on a utilisé dans l'exemple précédent <code>info break</code>).
</p>
<pre class="example">
(gdb) info program
	Using the running image of child process 27833.
Program stopped at 0x4004ff.
It stopped after being stepped.
Type "info stack" or "info registers" for more information.
(gdb) info stack
#0  0x00000000004004ff in main ()
(gdb) info registers
rax            0x400406	4195334
rbx            0x0	0
rcx            0x0	0
rdx            0x7fffffffdfa8	140737488347048
rsi            0x7fffffffdf98	140737488347032
rdi            0x1	1
rbp            0x400520	0x400520 &lt;__libc_csu_init&gt;
rsp            0x7fffffffdeb8	0x7fffffffdeb8
r8             0x7ffff7dd4dd0	140737351863760
r9             0x7ffff7de99d0	140737351948752
r10            0x833	2099
r11            0x7ffff7a2f950	140737348041040
r12            0x400400	4195328
r13            0x7fffffffdf90	140737488347024
r14            0x0	0
r15            0x0	0
rip            0x4004ff	0x4004ff &lt;main+9&gt;
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 
gs             0x0	0
(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000004004f6 &lt;main&gt;
	breakpoint already hit 1 time
(gdb) info address res
Symbol "res" is at 0x601039 in a file compiled without debugging.
(gdb) info address nb1
Symbol "nb1" is at 0x601038 in a file compiled without debugging.
</pre>

<p>
Les valeurs contenues dans les registres sont d'abord affichées en hexa puis en décimal.
</p>

<p>
Mais trop d'informations ne rendent pas lisibles le résultat. On préférera utiliser la commande <code>print</code> ou la commande <code>x</code> (allez voir <code>help print</code> et <code>help x</code>). Les principales options à connaître sont (vous pouvez remplacer <code>print</code> par <code>x</code> dans les exemples ci-dessous) :
</p>
<ul class="org-ul">
<li><code>print/x</code> affiche un résultat au format hexadécimal
</li>
<li><code>print/d</code> affiche un résultat au format décimal
</li>
<li><code>print/u</code> affiche un résultat au format décimal non signé
</li>
<li><code>print/t</code> affiche un résultat au format binaire
</li>
<li><code>print/c</code> affiche un résultat au format caractère
</li>
<li><code>print/s</code> affiche un résultat au format string
</li>
</ul>

<p>
Exemples avec les registres (commande <code>print</code> uniquement) : 
</p>
<pre class="example">
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/anne/enseign/numcirc2/15-16/src/premier 

Breakpoint 4, main () at premier.s:13
13	    	movb	%al, res	# poser la valeur dans le registre al 
(gdb) print/x $al
$19 = 0x6
(gdb) print/t $al
$25 = 110
(gdb) print/d $al
$26 = 6
(gdb) print/d $rax
$27 = 4195334
(gdb) print/t $rax
$28 = 10000000000010000000110
(gdb) print/x $rax
$29 = 0x400406
(gdb) print/t $eflags
$30 = 1000000110
</pre>

<p>
Pour connaître une valeur contenue dans la mémoire (à partir d'un endroit qu'on a nommé), il faut d'abord récupérer l'adresse précise associée à ce nom. On a plusieurs possibilités, avec <code>info</code>,  <code>print</code>, ou <code>x</code> :
</p>
<pre class="example">
(gdb) info address nb1
Symbol "nb1" is at 0x601038 in a file compiled without debugging.
(gdb) info address *nb1
No symbol "*nb1" in current context.
(gdb) print/d nb1
$1 = 1
(gdb) print/x &amp;nb1
$2 = 0x601038
(gdb) print/x *(&amp;nb1)
$3 = 1
(gdb) print/x *(&amp;nb1+1)
$4 = 0x0
(gdb) x/d &amp;res
0x601039:	0
(gdb) x/d 0x601038
0x601038:	1
</pre>

<p>
<code>print address nb1</code> retourne l'adresse mémoire associée à <code>nb1</code>. <code>print/d nb1</code> affiche le contenu de la mémoire à l'adresse <code>n1</code>. <code>print/x &amp;nb1</code> affiche l'adresse mémoire associée à <code>nb1</code>, et <code>print/x *(&amp;nb1)</code> affiche le contenu de la mémoire à l'adresse <code>nb1</code>. Cette dernière expression permet de faire des calculs sur des adresses mémoire.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Exercices</h2>
<div class="outline-text-2" id="text-3">
<div class="inlinetask">
<b>Somme des n premiers entiers</b><br  />
<p>
Proposez un programme en assembleur qui calcule la somme des <code>n</code> premiers entiers et stocke le résultat en mémoire à l'adresse <code>res</code>. 
</p>
</div>


<div class="inlinetask">
<b>Conversion de notes en lettres</b><br  />
<p>
On reprend l'exercice de la fiche TD 2 :
Proposez un programme en assembleur pour le problème suivant~: un étudiant a une note sur 20 à l'adresse <code>note</code>. On veut la transcrire en une lettre ('<code>A</code>', '<code>B</code>', '<code>C</code>', '<code>D</code>' ou '<code>E</code>') qui sera à l'adresse <code>res</code> en fonction de la règle suivante~:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">note</th>
<th scope="col" class="left">lettre</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">note&gt;=16</td>
<td class="left">A</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">14&lt;=note&lt;16</td>
<td class="left">B</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">12&lt;=note&lt;14</td>
<td class="left">C</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">10&lt;=note&lt;12</td>
<td class="left">D</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">note&lt;10</td>
<td class="left">E</td>
</tr>
</tbody>
</table>
</div>



<div class="inlinetask">
<b>Plus Petit Commun Multiple</b><br  />
<p>
<code>a</code> et <code>b</code> contiennent les valeurs de deux entiers non signés de 2 octets. Écrivez le programme assembleur qui pose dans <code>mult</code> le plus petit commun multiple de <code>a</code> et de <code>b</code> (vous utiliserez un algorithme à base d'additions uniquement).
</p>
</div>


<div class="inlinetask">
<b>Nombre maximal de régions du plan en fonction du nombre de droites</b><br  />
<p>
Soit <code>nb_droites</code> l'adresse d'un entier (sur 4 octets). On souhaite calculer le nombre maximal de régions du plan pour <code>nb_droites</code> droites. Ce nombre est donné par la suite : 
</p>

<ol class="org-ol">
<li>\(u_0\) = 1
</li>
<li>pour tout \(n>0\), \(u_n = n + u_{n-1}\) 
</li>
</ol>

<p>
Proposez un programme en assembleur qui met dans <code>%eax</code> le résultat.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Said Jabbour</p>
<p class="date">Created: janvier 2019</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
